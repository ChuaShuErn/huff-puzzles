
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

 #define function pushh(uint256 num) payable returns()
 #define function popp() payable returns()
 #define function read(uint256 index) payable returns(uint256)
 #define function length() payable returns(uint256)
 #define function write(uint256 index, uint256 num) payable returns()

 #define error OutOfBounds()
 #define error ZeroArray()

 // ----can we use storage?
 #define constant LEN = FREE_STORAGE_POINTER() //0

 #define macro MAIN() = takes(0) returns(0) {

    // where should we put the length lol


    0x00 calldataload 0xe0 shr// [sig]
    dup1 __FUNC_SIG(length) eq lengthLabel jumpi
    dup1 __FUNC_SIG(pushh) eq pushhLabel jumpi //[sig]
    dup1 __FUNC_SIG(popp) eq  poppLabel jumpi
    dup1 __FUNC_SIG(read) eq readLabel jumpi
    dup1 __FUNC_SIG(write) eq writeLabel jumpi

    0x00 0x00 revert
    
    lengthLabel:
        GET_LENGTH()
        finish jump
    readLabel:
        READ()
        finish jump
    pushhLabel:
        PUSHH()
        finish jump
    
    poppLabel:
        POPP()
        finish jump
    writeLabel:
        WRITE()
        finish jump

    

    outOfBounds:
        __ERROR(OutOfBounds) // [OutOfBounds selector]
        0x00 mstore 0x04 0x00 revert
    zeroArray:
        __ERROR(ZeroArray)
        0x00 mstore 0x04 0x00 revert
    finish:
    
 }

 #define macro PUSHH() = takes(0) returns (0) {

        [LEN] // [len_storage_pointer]
        sload // [len]
        // if len is 0, the push will be at slot 1
        // if len is 1, the push will be at slot 2
        // if len is n, the push will be at slot n+1
        dup1 // [len,len]
        0x01 add // [len+1,len]
        0x04 calldataload // [newEle,len+1,len]
        swap1 // [len+1,newEle,len]
        // len+1 is the key so // [key,newEle,len]
        sstore // [len]
        // increment len
        0x01 add // [len+1]
        [LEN] // [len_storage_pointer,len+1]
        sstore // []
 }

 #define macro POPP() = takes(0) returns(0){
    [LEN] //  [len_storage_pointer]
    sload // [len]
    // popp means pop last index
    //if len is zero revert
    dup1 // [len,len]
    iszero zeroArray jumpi
    // [len]
    // if len is 1, the last ele will be in slot 1
    // if len is 2, the last ele will be in slot 2
    // if len is n, the last ele will be in slot n
    // to erase it, probably means set to zero?

  
    // since len is here we can rename it to [len] to [targetSlot]
    0x00 // [0,targetSlot]
    swap1 // [targetSlot,0]
    // len is the same as the key here so // [key,0,len]
    sstore // []
    // decrement len
    [LEN] sload // [len]
    0x01 // [1,len]
    swap1 // [len,1]
    sub // [len - 1]
    [LEN] // [len_storage_pointer, len-1]
    sstore //[]
 }

 #define macro GET_LENGTH() = takes(0) returns (0){
    [LEN]
    sload // [len]
    0x00 mstore 0x20 0x00 return

 }

 #define macro READ() = takes (0) returns (0){
    0x04 calldataload // [index]
    dup1 // [index,index]
    // ok so if my len is 3, max index is 2
    // if my len is 5, max index is 4
    // if my len is 0, revert
    // if my len is n, max index is n-1
    // len must always be greater than index
  
    [LEN]  // [len_storage_pointer,index,index]
    sload // [len,index,index]
    dup1 // [len,len,index,index]
    iszero  //[len==?1:0,len,index,index]
    outOfBounds jumpi
    // [len,index,index]
    gt // [len>index,index]
    readContinue jumpi
    
    outOfBounds jump

    readContinue:
        
        // if index is 0, get a slot 1
        // if index is 2, get at slot 3
        // if index is n, get at slot n+1
        // [index]
        0x01 add // [index+1]
        sload // [ele at index]
        0x00 mstore 0x20 0x00 return
 }

 #define macro WRITE() = takes(0) returns (0){

    //uint256 index, uint256 num
    //assuming write is to override the index with given num
    //check if index out of bounds
    0x04 calldataload // [index]
    dup1 // [index,idex]
    [LEN] sload // [len,index,index]
    gt writeContinue jumpi

    outOfBounds jump

    writeContinue:
    // [index]
    0x01 add // [index+1 == key]
    0x24 calldataload // [num,key]
    swap1 // [key,num]
    sstore



 }