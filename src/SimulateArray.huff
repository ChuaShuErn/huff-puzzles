
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

// Assuming that this is a dynamic array where we can adjust length, because
// we can push
 #define function pushh(uint256 num) payable returns()
 #define function popp() payable returns()
 #define function read(uint256 index) payable returns(uint256)
 #define function length() payable returns(uint256)
 #define function write(uint256 index, uint256 num) payable returns()

 #define error OutOfBounds()
 #define error ZeroArray()

 // ----can we use storage?
 #define constant LEN = FREE_STORAGE_POINTER() //0

 #define macro MAIN() = takes(0) returns(0) {

    

    0x00 calldataload 0xe0 shr// [sig]
    dup1 __FUNC_SIG(length) eq lengthLabel jumpi
    dup1 __FUNC_SIG(pushh) eq pushhLabel jumpi //[sig]
    dup1 __FUNC_SIG(popp) eq  poppLabel jumpi
    dup1 __FUNC_SIG(read) eq readLabel jumpi
    dup1 __FUNC_SIG(write) eq writeLabel jumpi

    0x00 0x00 revert
    
    lengthLabel:
        GET_LENGTH()
        finish jump
    readLabel:
        READ()
        finish jump
    pushhLabel:
        PUSHH()
        finish jump
    
    poppLabel:
        POPP()
        finish jump
    writeLabel:
        WRITE()
        finish jump

    

    outOfBounds:
        __ERROR(OutOfBounds) // [OutOfBounds selector]
        0x00 mstore 0x04 0x00 revert
    zeroArray:
        __ERROR(ZeroArray)
        0x00 mstore 0x04 0x00 revert
    finish:
    
 }

 #define macro PUSHH() = takes(0) returns (0) {
        // if len is 0, the push will be at slot keccak(LEN_STORAGE_POINTER)+ 0 for index 0 ele
        // if len is 1, the push will be at slot keccak(LEN_STORAGE_POINTER) + 1 for index 1 ele
        // if len is n, the push will be at slot keccak(LEN_STORAGE_POINTER) + n for index n ele

        //STEP 1 : Store Keccak(pointer)
        [LEN]
        0x00 mstore // stack [] // mem [pointer]
        // STEP 2 prepare stack for sha3
    

        0x20 // [size] // mem [pointer]
        0x00 // [offset,size] // mem [pointer]
        sha3 // [keccak(pointer)] // []
        //STEP3: Get element
        0x04 calldataload // [ele,keccak(pointer)] // []
        // Step 4: Find out what slot we need to push to
        // Formula: keccak(pointer) + current len
        swap1 // [keccak(pointer), ele]
        [LEN] // [len_storage_pointer,keccak(pointer),ele] // 
        sload // [len,keccak(pointer),ele] /
        add // [len+keccak(pointer),ele]
       
        // Step 5: Store ele
          sstore // [] // []
        // Step 6: increment len
        [LEN] // [len_pointer] // []
        sload // [len]
        0x01 add // [len+1]
        [LEN]// [len_pointer, len+1]
        sstore // []  
 }

 #define macro POPP() = takes(0) returns(0){
    [LEN] //  [len_storage_pointer]
    sload // [len]
    // popp means pop last index
    //if len is zero revert
    dup1 // [len,len]
    iszero zeroArray jumpi
    // [len]
    // if len is 1, the last ele will be in keccak(pointer) + 0
    // if len is 2, the last ele will be in keccak(pointer) + 1
    // if len is n, the last ele will be in keccak(pointer) + (n-1) where n>0
    //[len]


    //STEP 1: KECCAK POINTER
    [LEN] // [pointer,len] // []
    0x00 mstore // [len] // [pointer]
    0x20 // [size,len] // [pointer]
    0x00 // [offset,size,len] // [pointer]
    sha3 // [keccak(pointer),len] // []

    //STEP 2: decrement len
    swap1 // [len,keccak(pointer)]
    0x01 // [1,len,keccak(pointer] 
    swap1 // [len,1,keccak(pointer] 
    sub // [len-1,keccak(pointer] 
    
    // Step3 GET Last Ele pointer
    add // [keccak(pointer) + len-1] // []

    //step4: set last ele pointer to point to 0
    0x00 // [0,keccak(pointer)+len-1] //  []
    swap1 // [keccak(pointer)+len-1,0] //  []
    sstore // [] // []

    //step 5: decrement len
    [LEN] // [storage pointer]
    dup1 // [storagepointer,storagepointer]
    sload // [len,storagepointer]
    0x01 // [1,len,storagepointer]
    swap1 // [len,1,storagepointer]
    sub // [len-1, storagepointer]
    swap1 // [storagepointer,len-1]
    sstore
 }

 #define macro GET_LENGTH() = takes(0) returns (0){
    [LEN]
    sload // [len]
    0x00 mstore 0x20 0x00 return

 }

 #define macro READ() = takes (0) returns (0){
    0x04 calldataload // [index]
    dup1 // [index,index]
    

  
    [LEN]  // [len_storage_pointer,index,index]
    sload // [len,index,index]
    dup1 // [len,len,index,index]
    iszero  //[len==?1:0,len,index,index]
    outOfBounds jumpi
    // [len,index,index]
    gt // [len>index,index]
    readContinue jumpi
    
    outOfBounds jump

    readContinue:

        // if index is 0, the storage slot is keccak(pointer) + 0
        // if index is 1, storage slot is keccak(pointer) + 1
        // if index is n, storage slot is keccak(pointer) + n where n < len     

        // [index]
        // STEP1 , get pointer
        [LEN]// [len_pointer,index]// []
        0x00 mstore // [index]// [len_pointer]
        0x20 // [size,index] // [len_pointer]
        0x00 // [offset,size,index]// [len_pointer]
        sha3 // [keccak(pointer),index]
        add // [keccak(pointer)+ index]
        //STEP2: use pointer to retrieve ele
        sload // [ele] // []
        0x00 mstore 0x20 0x00 return
 }

 #define macro WRITE() = takes(0) returns (0){

    //uint256 index, uint256 num
    //assuming write is to override the index with given num
    //check if index out of bounds
    0x04 calldataload // [index]
    dup1 // [index,idex]
    [LEN] sload // [len,index,index]
    gt writeContinue jumpi

    outOfBounds jump

    writeContinue:
    // [index]
    // STEP1: retrieve the pointer for this index
    // if index is 0, the storage slot is keccak(pointer) + 0
    // if index is 1, storage slot is keccak(pointer) + 1
    // if index is n, storage slot is keccak(pointer) + n where n < len 

    [LEN] // [len_pointer,index]// []
    0x00 mstore // [index] // [len_pointer]
    0x20// [size,index]//[len_pointer]
    0x00 // [offset,size,index] // []
    sha3 // [keccak(len_pointer),index] // []
    add // [keccak(lenPointer) + index] // []


    // Step 2 get the new value to for this pointer
    0x24 calldataload // [newEle,keccak(lenPointer)+index]
    swap1 // [keccak(lenPointer)+index,new ele]
    
    //Step 3: store this new value to this pointer

    sstore
  


 }